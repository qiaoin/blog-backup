<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-04-02 Sun 17:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>二机制炸弹实验</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="qiaoin" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/site.css"/>
<link rel="icon" href="favicon.ico">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div class="header">
              <a href="https://aprilwith.me">自在随心</a> | <a href="http://github.com/qiaoin">Github</a>
          </div>
</div>
<div id="content">
<h1 class="title">二机制炸弹实验</h1>
<p>
一直对 《深入理解计算机系统》 心怀“敬畏”，这一周就给自己严格定了一个目标，三章(Chapter3&amp;5&amp;6)内容，五天看完，开始看、抓紧看、努力看，把之前落下的知识点全给好好的梳理一遍，确实涵盖的知识点很多，但基本上在之前的课上都了解过，CSAPP 讲的也不是很深，基本上可以很快的理解，但还是看着看着，有的地方会惊呼，这也可以，这样也行。 CSAPP 给提供了一个思路，如何去进行学习，将实践与理论进行结合，将对汇编语言的讲解用等价的 C 语言来进行描述，对一个简单的程序进行一步步的优化，直呼过瘾。遂加紧加忙，将课程提供的实验打算慢慢做来，花费了将近四天的时间将 Lab2 的 二进制炸弹问题入了一个门，也是将自己的思路给整理下来，权当备忘。
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf1c7735">准备</a></li>
<li><a href="#org53723b1">首先是尝试</a></li>
<li><a href="#orgeea079c"><code>phase_1</code></a></li>
<li><a href="#org71cb296"><code>phase_2</code></a></li>
<li><a href="#orgb02b810"><code>phase_3</code></a></li>
<li><a href="#org77a3a73"><code>phase_4</code></a></li>
<li><a href="#org2395c07"><code>phase_5</code></a></li>
<li><a href="#org7718d8a"><code>phase_6</code></a></li>
<li><a href="#org5778f33"><code>secret_phase</code></a></li>
<li><a href="#org586dc20">总结</a></li>
<li><a href="#orgf697da0">参考资料</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf1c7735" class="outline-2">
<h2 id="orgf1c7735">准备</h2>
<div class="outline-text-2" id="text-orgf1c7735">
<ul class="org-ul">
<li>目标：
<ul class="org-ul">
<li>Gain basic familiarity with x86-64 assembly instructions and how they are used
to implement comparison, loops, switch statements, recursion, pointers,
and arrays.</li>
<li>Gain exprience using <code>gdb</code> debugger to step through assembly code and other 
tools such as <code>objdump</code> .</li>
</ul></li>
<li>文件：
<ul class="org-ul">
<li><code>bomb</code> : The executable binary bomb</li>
<li><code>bomb.c</code> : Source file with the bomb's main routine</li>
<li><code>defuser.txt</code> : File that contains defusing solutions</li>
</ul></li>
<li>运行 ./bomb defuser.txt
说明： put answer for each phase in one line. Make sure all answers, including
the last one, have a newline character afterwards, so even last-phase answer is
a complete line with a newline.</li>
<li>x86-64 Calling Conventions
The x86-64 ISA passes the first six arguments to a function in registers. 
Registers are used in the following order: <code>rdi</code> , <code>rsi</code> , <code>rdx</code> , <code>rcx</code> , <code>r8</code> ,
<code>r9</code> . The return value for functions is passed in <code>rax</code> .</li>
<li>Tools(Read This!!):
<ul class="org-ul">
<li><code>gdb</code> : <code>gdb help</code>
trace through a program line by line, examine memory and registers, look at
both the source code and assembly code (not giving the source code for most of
<code>bomb</code> ), set breakpoints, set memory watch points, and write scripts</li>
<li><code>objdump -t bomb</code> :
This will print out the bomb's symbol table. The symbol table includes the names
of all functions and global variables in the bomb, the names of all the 
functions the bomb calls, and their addresses. You may learn something by 
looking at the function names.</li>
<li><code>objdump -d bomb</code> :
Use this to disassemble all the code in the bomb. You can also just look at 
individual functions. Reading the assembler code can tell you how the bomb 
works. Although <code>objdump -d</code> gives you a lot of information, it doesn't tell 
you the whole story. Calls to system-level functions may look cryptic. For 
example, a call to <code>sscanf</code> might appers as: <code>8048c36: e8 99 fc ff ff call 
    80488d4 &lt;_init+0x1a0&gt;</code> . To determine that the call was to <code>sscanf</code> , you would
need to disassemble within <code>gdb</code> .</li>
<li><code>strings -t x bomb</code> :
This utility will display the printalbe strings in your boom and their offset 
within the bomb.</li>
<li>commands <code>apropos</code> and <code>man</code> : <code>man assii</code></li>
</ul></li>
<li>Hints:
Here are some hints for what to think about at each stage:
<ol class="org-ol">
<li>comparison;</li>
<li>loops;</li>
<li>switch statements;</li>
<li>recursion;</li>
<li>points and arrays;</li>
<li>sorting linked lists.</li>
</ol></li>
</ul>
</div>
</div>


<div id="outline-container-org53723b1" class="outline-2">
<h2 id="org53723b1">首先是尝试</h2>
<div class="outline-text-2" id="text-org53723b1">
<ul class="org-ul">
<li>使用 <code>objdump -t bomb &gt; system.txt</code> 输出 <code>bomb</code> 中的所有符号置 <code>symbol.txt</code> 文件；</li>
<li>使用 <code>strings -t x bomb &gt; strigs.txt</code> 输出 <code>bomb</code> 中所有的可打印字符置 <code>stings.txt</code> 文件；</li>
<li>使用 <code>objdump -d bomb &gt; objdump-d.txt</code> 输出 <code>bomb</code> 的汇编文件，置 <code>objdump-d.txt</code> 文件。</li>
</ul>

<p>
当然，需要先大致理一下这三个生成的文件的内容，特别是 <code>objdump-d.txt</code> 文件，其为我们后面分析的核心。
</p>
</div>
</div>


<div id="outline-container-orgeea079c" class="outline-2">
<h2 id="orgeea079c"><code>phase_1</code></h2>
<div class="outline-text-2" id="text-orgeea079c">
<p>
在 <code>objdump-d.txt</code> 文件中，关于 <code>phase_1</code> 的汇编代码如下（删除了其中的机器代码表示，并且如同 CSAPP chapter3 的做法在每行汇编之后添加注释）：
</p>
<div class="org-src-container">
<pre class="src src-ASM">0000000000400ee0 &lt;phase_1&gt;:
  400ee0:	sub    $0x8,%rsp                   ;; 分配 8 bytes 的栈帧大小
  400ee4:	mov    $0x402400,%esi              ;; 将内存地址 0x402400 移入 esi，作为 strings_not_equal 函数的参数
  400ee9: callq  401338 &lt;strings_not_equal&gt;  ;; 调用 strings_not_equal 函数
  400eee: test   %eax,%eax                   ;; 测试 eax 是否为空
  400ef0:	je     400ef7 &lt;phase_1+0x17&gt;       ;; 如果 eax 为 0(即 strings_not_equal 函数返回为 0，两个字符串相等)，则跳转
  400ef2:	callq  40143a &lt;explode_bomb&gt;       ;; strings_not_equal 函数返回值非 0，即猜测的字符串与原始字符串不相等，炸弹爆炸
  400ef7:	add    $0x8,%rsp                   ;; 释放栈帧
  400efb:	retq                               ;; 函数返回
</pre>
</div>
<p>
从这段汇编代码中，可以得到的信息有：
</p>
<ol class="org-ol">
<li><p>
<code>strings_not_equal</code> 作为一个通用函数（在后面 <code>phase_x</code> x=2&#x2026;6 中也用到了），在比较两个字符串（ <code>rdi</code> 保存的是读取入的字符串首地址， <code>rsi</code> 保存源字符串首地址）的长度之后（若长度不相等，其他的更不用比了），对每个字符（字符是 8 位）依次进行比较
</p>
<div class="org-src-container">
<pre class="src src-ASM">40133c: mov    %rdi,%rbx                       ;; 将第一个参数保存在 rbx 寄存器
40133f: mov    %rsi,%rbp                       ;; 将第二个参数保存在 rbp 寄存器
......
......
40136a: cmp    0x0(%rbp),%al                   ;; 同一位置的两个字符进行能够比较
40136d: nopl   (%rax)                          ;; 用于对齐
401370: jne    401396 &lt;strings_not_equal+0x5e&gt; ;; 如果相等就接着执行下一行汇编代码，比较下一个字符；否则，
401372: add    $0x1,%rbx                       ;; 指向待比较字符串的下一个字符
401376: add    $0x1,%rbp                       ;; 指向源字符串的下一个字符
40137a: movzbl (%rbx),%eax                     ;; 将待比较字符移入 
40137d: test   %al,%al                         ;; 字符是否为 ‘/0’ (十六进制 00 表示的 ASCII 码)，即是否到达字符串末尾
40137f: jne    40136a &lt;strings_not_equal+0x32&gt; ;; 若未到达字符串末尾
...... 
401396: mov    $0x1,%edx                       ;; 赋 edx 为 1
40139b: mov    %edx,%eax                       ;; 将 edx 的值作为返回值返回
</pre>
</div>
<p>
<code>string_not_equal</code> 为字符串比较函数，其接受两个参数，分别是待比较字符串和源字符串的首地址，若两字符串相等，返回 0；否则返回 1。
</p></li>
<li>源字符串的首地址保存在 <code>esi</code> 中，值为 <code>0x402400</code> ， <code>phase_1</code> 求解关键。</li>
<li><p>
待比较字符串首地址是如何传入 <code>rdi</code> 中的呢？在 <code>main</code> 的汇编代码部分观察对 <code>phase_x</code> (x=1&#x2026;6) 的调用总是重复以下六行汇编代码（以 <code>phase_1</code> 为例）：
</p>
<div class="org-src-container">
<pre class="src src-ASM">400e28: mov    $0x402378,%edi
400e2d: callq  400b10 &lt;puts@plt&gt;
400e32: callq  40149e &lt;read_line&gt;
400e37: mov    %rax,%rdi
400e3a: callq  400ee0 &lt;phase_1&gt;
400e3f: callq  4015c4 &lt;phase_defused&gt;
</pre>
</div>
<p>
可见， <code>rdi</code> 中保存的是 <code>read_line</code> 的返回值，我们没有必要去看 <code>read_line</code> 是如何实现的了，其功能就是读取标准输入的一行内容并返回字符串首地址。
</p></li>
</ol>

<p>
<b><code>solution_1</code></b> 
</p>

<ol class="org-ol">
<li><code>gdb bomb</code> : 使用 <code>gdb</code> 调试可执行文件 <code>bomb</code> ，在 <code>gdb</code> 读取完可执行文件的所有 <code>symbol</code> 之后会停下来，等待命令输入；</li>
<li><code>b phase_1</code> : 在函数 <code>phase_1</code> 的入口处设置断点，程序运行至此会停下来，这时候我们就可以查看程序的运行状态；</li>
<li><code>r(un)</code> : 程序开始执行，等待用户输入待比较的字符串，输入之后，程序接着执行，至 <code>phase_1</code> 时停下来，称 <code>breakpoint hits</code></li>
<li><code>info b</code> : 查看断点状态；</li>
<li><code>info r</code> : 查看寄存器状态，能够看到全部寄存器以及各自对应的值，发现 <code>rsi</code> 为 <code>0x603780</code> （不为 <code>0x402400</code> ，因为我们还没有对其进行赋值）；</li>
<li><code>b strings_not_equal</code> : 在对 <code>rsi</code> 赋值之后，在 <code>strings_not_equal</code> 函数入口处设置断点；</li>
<li><code>c(ontinue)</code> : 程序从 <code>phase_1</code> 断点处继续开始执行，执行至 <code>strings_not_equal</code> 处中断；</li>
<li><code>info r</code> : <code>rsi</code> 此时的值已经为 <code>0x402400</code> ;</li>
<li><code>x/s 0x402400</code> : 查看源字符串的内容（若仅仅希望得出答案，只需要执行这里的 1 和 9 两步）。</li>
</ol>

<p>
<b>备注</b> <code>gdb</code> 中 <code>x</code> 命令的用法： 
</p>

<p>
可以使用 <code>examine</code> 命令（简写是 <code>x</code> ）来查看内存地址中的值。 <code>x</code> 命令的语法如下所示：
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #969896;">(</span><span style="color: #c33700;">gdb</span><span style="color: #969896;">)</span> <span style="color: #d31428;">x/</span>&lt;<span style="color: #00844f;">n/f/u</span>&gt; &lt;<span style="color: #0083d4;">addr</span>&gt;
</pre>
</div>
<p>
<code>n</code> 、 <code>f</code> 、 <code>u</code> 是可选的参数，三个参数可以一起使用。 <code>&lt;addr&gt;</code> 表示一个内存地址。
</p>

<ul class="org-ul">
<li><code>n</code> 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</li>
<li><code>f</code> 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 <code>s</code> ，如果 地址是指令地址，那么格式可以是i。</li>
<li><code>u</code> 表示从当前地址往后请求的字节数，如果不指定的话， <code>gdb</code> 默认是 4 个 bytes。 <code>u</code> 参数可以用下面的字符来代替， <code>b</code> 表示单字节（默认）， <code>h</code> 表示双字节， <code>w</code> 表示四字节， <code>g</code> 表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</li>
</ul>

<p>
例如：命令 <code>x/3uh 0x54320</code> 表示，从内存地址 <code>0x54320</code> 读取内容， <code>h</code> 表示以双字节为一个单位， <code>3</code> 表示三个单位， <code>u</code> 表示按十六进制显示。
</p>
</div>
</div>


<div id="outline-container-org71cb296" class="outline-2">
<h2 id="org71cb296"><code>phase_2</code></h2>
<div class="outline-text-2" id="text-org71cb296">
<p>
<code>rdi</code> 始终保持着待比较字符串的首地址，而且作为多个函数的第一个传入参数。
</p>

<p>
我们已经提及了 x84-64 中函数参数传递的一些惯例，另外还有一些我们需要注意：
</p>
<blockquote>
<p>
(CSAPP chapter3 P172 3.7.5 寄存器中的局部存储空间)
</p>

<p>
寄存器组是唯一被所有过程共享的资源。虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此， x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。
</p>

<p>
根据惯例，寄存器 <code>%rbx</code> 、 <code>%rbp</code> 和 <code>%r12</code> ~ <code>%r15</code> 被划分为 <b>被调用者保存寄存器</b> 。当过程 <code>P</code> 调用过程 <code>Q</code> 时， <code>Q</code> 必须保存这些寄存器的值，保证它们的值在 <code>Q</code> 返回到 <code>P</code> 时与 <code>Q</code> 被调用时是一样的。过程 <code>Q</code> 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器” 的一部分。有了这条惯例， <code>P</code> 的代码就能安全地把值存在被调用者保存的寄存器中（当然，要先把之前的值保存到栈上），调用 <code>Q</code> ， <code>Q</code> 返回，然后 <code>P</code> 继续使用寄存器中的值，不用担心值被破坏。
</p>

<p>
所有其他寄存器，除了栈指针 <code>%rsp</code> ，都分类为 <b>调用者保存寄存器</b> 。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”：过程 <code>P</code> 在某个此类寄存器中有局部数据，然后调用过程 <code>Q</code> 。因为 <code>Q</code> 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据就是 <code>P</code> (调用者)的责任了。
</p>
</blockquote>

<p>
首先，来看看对数组的初始化：
</p>

<div class="org-src-container">
<pre class="src src-ASM">0000000000400efc &lt;phase_2&gt;:
  400efc:	push   %rbp                       ;; 保存 rbp
  400efd:	push   %rbx                       ;; 保存 rbx
  400efe:	sub    $0x28,%rsp                 ;; 分配栈帧，40 bytes
  400f02:	mov    %rsp,%rsi                  ;; 将数组首地址移入 rsi (读入六个数字，将它们保存在数组中)
  400f05:	callq  40145c &lt;read_six_numbers&gt;  ;; 调用 read_six_numbers 函数，其有两个参数（读入的字符串首地址 rdi 和待存入数值的数组首地址 rsi）
  ......
</pre>
</div>


<div class="org-src-container">
<pre class="src src-ASM">000000000040145c &lt;read_six_numbers&gt;: 
  40145c: sub    $0x18,%rsp                    ;; 分配栈帧
  401460:	mov    %rsi,%rdx                     ;;
  401463:	lea    0x4(%rsi),%rcx                ;;
  401467:	lea    0x14(%rsi),%rax               ;;
  40146b:	mov    %rax,0x8(%rsp)                ;;
  401470:	lea    0x10(%rsi),%rax               ;;
  401474:	mov    %rax,(%rsp)                   ;;
  401478:	lea    0xc(%rsi),%r9                 ;;
  40147c:	lea    0x8(%rsi),%r8                 ;; 设置六个地址参数（ rdx、rcx、r8、r9 和两个通过栈传递的参数，分别对应数组的前六个元素）
  401480:	mov    $0x4025c3,%esi                ;; esi 保存格式化字符串的首地址（ "%d %d %d %d %d %d %d" ）
  401485:	mov    $0x0,%eax                     ;; eax 之后要作为 sscanf 函数的返回值，故在调用前清零
  40148a:	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;  ;; 调用 sscanf 函数
  40148f:	cmp    $0x5,%eax                     ;; 读取的数字是否大于 5，即至少包含 6 个数字
  401492:	jg     401499 &lt;read_six_numbers+0x3d&gt;;; 大于 5 个数字，安全返回
  401494:	callq  40143a &lt;explode_bomb&gt;         ;; 炸弹爆炸
  401499:	add    $0x18,%rsp                    ;; 释放栈帧
  40149d:	retq                                 ;; 函数返回
</pre>
</div>

<p>
从汇编代码可以看出，在读入数字时调用了 C 语言函数库的 <code>sscanf</code> 函数，其函数原型为：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #a71d5d;">#include</span> <span style="color: #969896;">&lt;</span><span style="color: #183691;">stdio.h</span><span style="color: #969896;">&gt;</span>

<span style="color: #0086b3;">int</span> <span style="color: #7e6900;">scanf</span><span style="color: #969896;">(</span><span style="color: #d31229;">const</span> <span style="color: #0086b3;">char</span> *<span style="color: #008341;">format</span>, ...<span style="color: #969896;">)</span>;
<span style="color: #0086b3;">int</span> <span style="color: #6d6f00;">sscanf</span><span style="color: #969896;">(</span><span style="color: #d31229;">const</span> <span style="color: #0086b3;">char</span> *<span style="color: #00858b;">str</span>, <span style="color: #d31229;">const</span> <span style="color: #0086b3;">char</span> *<span style="color: #008341;">format</span>, ...<span style="color: #969896;">)</span>;
</pre>
</div>
<p>
这里，我们将 <code>scanf</code> 的原型也列了出来，毕竟学习一个新的东西，需要与已经熟悉的知识点形成比较才好理解。 <code>scanf</code> 函数读取标准输入， <code>format</code> 给定格式化字符串， <code>...</code> 给定相应的存放地址。同理， <code>sscanf</code> 仅仅是从 <code>str</code> 指定的地址处读取信息，使用 <code>format</code> 来格式化字符串， <code>...</code> 为存放地址。因此，可以认为 <code>read_six_numbers</code> 函数在调用 <code>sscanf</code> 的时候需要准备好至少 8 个参数，以 x86-64 调用函数的惯例来排列， <code>edi</code> 保存 <code>read_line</code> 字符串的首地址， <code>esi</code> 保存格式化字符串（可以通过 <code>x/s &lt;%esi&gt;</code> 来查看）， <code>rdx</code> 、 <code>rcx</code> 、 <code>r8</code> 、 <code>r9</code> 和另外两个参数通过栈实现传递，进行数组的初始化工作。如下图所示：
</p>


<div class="figure">
<p><img src="http://7xrxoi.com1.z0.glb.clouddn.com/read_six_numbers_stack_state.png" alt="read_six_numbers_stack_state.png" />
</p>
</div>

<p>
之后调用 <code>sscanf</code> 函数，就会将数组元素进行赋值。那如何判断所赋之值是多少呢？这就需要我们对 <code>Phase_2</code> 进行更加细致的分析了（需结合其后的等价 C 代码进行理解）。
</p>
<div class="org-src-container">
<pre class="src src-ASM">0000000000400efc &lt;phase_2&gt;:
  400efc:	push   %rbp                       ;; 保存 rbp
  400efd:	push   %rbx                       ;; 保存 rbx
  400efe:	sub    $0x28,%rsp                 ;; 分配栈帧，40 bytes
  400f02:	mov    %rsp,%rsi                  ;; 设置数组首地址
  400f05:	callq  40145c &lt;read_six_numbers&gt;  ;; 调用 read_six_numbers ，对数组前六个元素进行赋值
  400f0a:	cmpl   $0x1,(%rsp)                ;; 此时，read_six_numbers 函数已返回，其栈帧释放，rsp 指向数组首元素地址，判断第一个元素是否为 1
  400f0e:	je     400f30 &lt;phase_2+0x34&gt;      ;; 数组第一个元素为 1 则跳转
  400f10:	callq  40143a &lt;explode_bomb&gt;      ;; 不为 1 则炸弹爆炸
  400f15:	jmp    400f30 &lt;phase_2+0x34&gt;      ;;  
  400f17:	mov    -0x4(%rbx),%eax            ;; a[i-1] 当前比较元素的前一个元素
  400f1a:	add    %eax,%eax                  ;; 2 * a[i-1]
  400f1c:	cmp    %eax,(%rbx)                ;; 比较 a[i] 和 两倍的a[i-1]
  400f1e: je     400f25 &lt;phase_2+0x29&gt;      ;; a[i] == 2*a[i-1]
  400f20:	callq  40143a &lt;explode_bomb&gt;      ;; a[i] != 2*a[i-1]
  400f25:	add    $0x4,%rbx                  ;; i++，判断下一个元素
  400f29:	cmp    %rbp,%rbx                  ;; i &lt; 6，判断是否越界
  400f2c:	jne    400f17 &lt;phase_2+0x1b&gt;      ;; 循环
  400f2e:	jmp    400f3c &lt;phase_2+0x40&gt;      ;; i == 6，数组前六个元素已比较完毕
  400f30: lea    0x4(%rsp),%rbx             ;; i = 1，初始化
  400f35: lea    0x18(%rsp),%rbp            ;; a+6 ，即数组最后一个元素的下一个地址，表示数组界限
  400f3a: jmp    400f17 &lt;phase_2+0x1b&gt;      ;; 进入循环
  400f3c: add    $0x28,%rsp                 ;; 释放栈帧
  400f40:	pop    %rbx                       ;; 恢复 rbp
  400f41:	pop    %rbp                       ;; 恢复 rbx
  400f42:	retq                              ;; 函数返回
</pre>
</div>
<p>
根据对 <code>phase_2</code> 汇编代码的理解，写出大致的 C 语言等价形式（帮助理解）：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00845b;">static</span> <span style="color: #0086b3;">void</span> <span style="color: #794ed6;">phase_2</span><span style="color: #969896;">(</span><span style="color: #d31229;">const</span> <span style="color: #0086b3;">char</span> *<span style="color: #00858b;">str</span><span style="color: #969896;">)</span> <span style="color: #969896;">{</span>
  <span style="color: #0086b3;">int</span> <span style="color: #00800f;">a</span><span style="color: #0086b3;">[</span><span style="color: #0086b3;">6</span><span style="color: #0086b3;">]</span> = <span style="color: #0086b3;">{</span><span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span><span style="color: #0086b3;">}</span>;
  <span style="color: #c33800;">read_six_number</span><span style="color: #0086b3;">(</span><span style="color: #00858b;">str</span>, <span style="color: #00800f;">a</span><span style="color: #0086b3;">)</span>;      <span style="color: #969896;">/* </span><span style="color: #969896;">1, 2, 4, 8, 16, 32 </span><span style="color: #969896;">*/</span>
  <span style="color: #0083d2;">if</span> <span style="color: #0086b3;">(</span><span style="color: #00800f;">a</span><span style="color: #969896;">[</span><span style="color: #0086b3;">0</span><span style="color: #969896;">]</span> == <span style="color: #0086b3;">1</span><span style="color: #0086b3;">)</span> <span style="color: #0086b3;">{</span>
    <span style="color: #0086b3;">size_t</span> <span style="color: #796b00;">i</span>;
    <span style="color: #0082da;">for</span> <span style="color: #969896;">(</span><span style="color: #796b00;">i</span> = <span style="color: #0086b3;">1</span>; <span style="color: #796b00;">i</span> &lt; <span style="color: #0086b3;">6</span>; <span style="color: #796b00;">i</span>++<span style="color: #969896;">)</span> <span style="color: #969896;">{</span>
      <span style="color: #0083d2;">if</span> <span style="color: #795da3;">(</span><span style="color: #00800f;">a</span><span style="color: #969896;">[</span><span style="color: #796b00;">i</span><span style="color: #969896;">]</span> != <span style="color: #0086b3;">2</span>*<span style="color: #00800f;">a</span><span style="color: #969896;">[</span><span style="color: #796b00;">i</span>-<span style="color: #0086b3;">1</span><span style="color: #969896;">]</span><span style="color: #795da3;">)</span> <span style="color: #795da3;">{</span>
        <span style="color: #d60075;">explode_bomb</span><span style="color: #969896;">()</span>;
      <span style="color: #795da3;">}</span>
    <span style="color: #969896;">}</span>
  <span style="color: #0086b3;">}</span> <span style="color: #0084c9;">else</span> <span style="color: #0086b3;">{</span>
    <span style="color: #d60075;">explode_bomb</span><span style="color: #969896;">()</span>;
  <span style="color: #0086b3;">}</span>
<span style="color: #969896;">}</span>
</pre>
</div>

<p>
现在就很清晰了。
</p>


<div class="figure">
<p><img src="http://7xrxoi.com1.z0.glb.clouddn.com/phase_2_stack_state.png" alt="phase_2_stack_state.png" />
</p>
</div>

<p>
<b><code>solution_2</code></b>
</p>

<ol class="org-ol">
<li><code>x/s 0x4025c3</code> : 得到 "%d %d %d %d %d %d" 的格式化字符串，期望得到 6 个整数；</li>
<li><code>b * 400f0a</code> : 在从 <code>read_six_numbers</code> 函数返回后，中断执行；</li>
<li><code>r</code> : 开始执行 <code>bomb</code> ；</li>
<li><code>0 0 0 0 0 0</code> : 期望得到 6 个整数，函数在 <code>400f0a: cmpl $0x1, (%rsp)</code> 处中断；</li>
<li><code>info r</code> : 查看寄存器 <code>rsp</code> 所指示的地址 <code>0x7fffffffdb10</code> ；</li>
<li><code>set * 0x7fffffffdb10 = 1</code> : 设置 <code>rsp</code> 所执行的内存单元的值为 1，以通过比较，否则炸弹就会爆炸；</li>
<li><code>si</code> 多次: 单步执行，可知函数到 <code>0x400f30</code> 处接着执行</li>
<li>之后使用 <code>si</code> 单步执行， <code>info r</code> 打印寄存器信息， <code>x/i &lt;addr&gt;</code> 查看当前执行的语句；</li>
<li>重复 6、7、8 多次即可。</li>
<li><code>1 2 4 8 16 32</code> 即为所求。</li>
</ol>
</div>
</div>


<div id="outline-container-orgb02b810" class="outline-2">
<h2 id="orgb02b810"><code>phase_3</code></h2>
<div class="outline-text-2" id="text-orgb02b810">
<p>
有了之前两个 <code>phase</code> 的基础，这个就比较简单了（具体知识点，例如跳转表，可参考 CSAPP chapter3 3.6.8 switch 语句 P159）
</p>
<div class="org-src-container">
<pre class="src src-ASM">0000000000400f43 &lt;phase_3&gt;:
  400f43:	sub    $0x18,%rsp
  400f47:	lea    0xc(%rsp),%rcx
  400f4c:	lea    0x8(%rsp),%rdx
  400f51:	mov    $0x4025cf,%esi                 ;; 格式化字符串为 "%d %d"
  400f56:	mov    $0x0,%eax
  400f5b:	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;
  400f60:	cmp    $0x1,%eax                      ;; 读入两个数字
  400f63:	jg     400f6a &lt;phase_3+0x27&gt;
  400f65:	callq  40143a &lt;explode_bomb&gt;
  400f6a:	cmpl   $0x7,0x8(%rsp)                 ;; 读入的第一个数字小于等于7
  400f6f:	ja     400fad &lt;phase_3+0x6a&gt;
  400f71:	mov    0x8(%rsp),%eax                 ;; 第一个数字为索引值
  400f75: jmpq   *0x402470(,%rax,8)             ;; 间接跳转， 0x402470 给出跳转表首地址， rax 保存索引值
  400f7c:	mov    $0xcf,%eax                     ;; index = 0
  400f81:	jmp    400fbe &lt;phase_3+0x7b&gt;
  400f83:	mov    $0x2c3,%eax                    ;; index = 2
  400f88:	jmp    400fbe &lt;phase_3+0x7b&gt;
  400f8a:	mov    $0x100,%eax                    ;; index = 3
  400f8f:	jmp    400fbe &lt;phase_3+0x7b&gt;
  400f91:	mov    $0x185,%eax                    ;; index = 4
  400f96: jmp    400fbe &lt;phase_3+0x7b&gt;
  400f98:	mov    $0xce,%eax                     ;; index = 5
  400f9d:	jmp    400fbe &lt;phase_3+0x7b&gt;
  400f9f:	mov    $0x2aa,%eax                    ;; index = 6
  400fa4:	jmp    400fbe &lt;phase_3+0x7b&gt;
  400fa6:	mov    $0x147,%eax                    ;; index = 7
  400fab:	jmp    400fbe &lt;phase_3+0x7b&gt;
  400fad:	callq  40143a &lt;explode_bomb&gt;
  400fb2:	mov    $0x0,%eax
  400fb7:	jmp    400fbe &lt;phase_3+0x7b&gt;
  400fb9:	mov    $0x137,%eax                    ;; index = 1
  400fbe:	cmp    0xc(%rsp),%eax                 ;; 读入的第二个数字等于 eax 中新赋的值
  400fc2:	je     400fc9 &lt;phase_3+0x86&gt;
  400fc4:	callq  40143a &lt;explode_bomb&gt;
  400fc9:	add    $0x18,%rsp
  400fcd:	retq
</pre>
</div>
<p>
有此可知，有 7 组结果都满足要求。
</p>

<p>
<b><code>solution_3</code></b>
</p>

<ol class="org-ol">
<li><code>x/8xg 0x402470</code> : 分析得到索引值小于或等于 7 （也就是最多 8 个），得到输出刚好就是上面注释中 <code>index</code> 所对应的地址；</li>
<li><code>b * 400f75</code> : 在进行跳转前中断；</li>
<li><code>r</code> : 运行程序，输入 <code>3 255</code> (不一定要是 3，小于等于 7 就可以； 256 也是随便定的)  ，程序在跳转之前中断；</li>
<li><code>set $rax = 1</code> : 设置跳转表索引为 index = 1 ；</li>
<li><code>si</code> : 单步执行，会来到 <code>ox400fb9</code> 处，并将设置 <code>eax</code> 为 <code>0x137</code> ；</li>
<li><code>info r</code> : 得到 <code>rsp</code> 表示的内存地址为 <code>0x7fffffffdb30</code> ；</li>
<li><code>set 0x7fffffffdb3c = 0x137</code> : 设置读入的第二个数为 <code>0x137</code> ；</li>
<li><code>si</code> : 单步执行之后，到达 <code>0x400fc2</code> <code>0x400fc9</code> 说明我们设置的 1 和 <code>0x137</code> （311）满足要求。更一般地，这个 <code>switch</code> 语句有 7 组满足要求的解，以列表形式表示为： <br />
<code>[(0, 207), (1, 311), (2, 707), (3, 256), (4, 389), (5, 206), (6, 682), (7, 327)]</code></li>
</ol>
</div>
</div>


<div id="outline-container-org77a3a73" class="outline-2">
<h2 id="org77a3a73"><code>phase_4</code></h2>
<div class="outline-text-2" id="text-org77a3a73">
<div class="org-src-container">
<pre class="src src-ASM">000000000040100c &lt;phase_4&gt;:
  40100c:	sub    $0x18,%rsp                     ;; 分配栈帧
  401010:	lea    0xc(%rsp),%rcx                 ;; 设置 sscanf 的第 4 个参数
  401015:	lea    0x8(%rsp),%rdx                 ;; 设置 sscanf 的第 3 个参数
  40101a:	mov    $0x4025cf,%esi                 ;; 格式化字符串为 "%d %d"
  40101f:	mov    $0x0,%eax                      ;; eax 清零
  401024:	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;   ;; 调用 sscanf 函数， edi 指示待输入的字符串， esi 为格式字符串，另两个参数 rdx rcs 已设置好，保存在栈上
  401029:	cmp    $0x2,%eax                      ;; 是否读入两个数字
  40102c:	jne    401035 &lt;phase_4+0x29&gt;          ;; sscanf 返回非 2，则跳转，炸弹爆炸
  40102e:	cmpl   $0xe,0x8(%rsp)                 ;; 读入的第一个数字与 14 进行比较
  401033:	jbe    40103a &lt;phase_4+0x2e&gt;          ;; 第一个数字小于或等于 14 则跳转，否则爆炸
  401035:	callq  40143a &lt;explode_bomb&gt;          ;; 调用 explode_bomb
  40103a:	mov    $0xe,%edx                      ;; 第三个参数，14
  40103f:	mov    $0x0,%esi                      ;; 第二个参数，0
  401044:	mov    0x8(%rsp),%edi                 ;; 第一个参数，也就是读入的一个数字
  401048:	callq  400fce &lt;func4&gt;                 ;; 调用函数 func4  &lt;=======如何分析？
  40104d:	test   %eax,%eax                      ;; 返回值 eax 是否为 0
  40104f:	jne    401058 &lt;phase_4+0x4c&gt;          ;; 若非零则跳转，炸弹爆炸（即递归调用的返回值需要为 0）
  401051:	cmpl   $0x0,0xc(%rsp)                 ;; 第二个读入的数字为 0
  401056: je     40105d &lt;phase_4+0x51&gt;          ;; 若第二个数字为 0，则跳转
  401058:	callq  40143a &lt;explode_bomb&gt;          ;; 否则炸弹就会爆炸
  40105d:	add    $0x18,%rsp                     ;; 释放栈帧
  401061:	retq                                  ;; 函数返回
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ASM">0000000000400fce &lt;func4&gt;: 第一个参数 A edi 、 第二个参数 B esi 、 第三个参数 C edx
  400fce:	sub    $0x8,%rsp                      ;; 分配栈帧
  400fd2:	mov    %edx,%eax                      ;; C                  eax
  400fd4:	sub    %esi,%eax                      ;; C - B         更新 eax
  400fd6:	mov    %eax,%ecx                      ;; C - B              ecx 
  400fd8:	shr    $0x1f,%ecx                     ;; 右移 31 位， ecx 长为 32 位（也就是之前的最高位变为最低位，其余 31 位填充补 0），可以认为 ecx = 0
  400fdb:	add    %ecx,%eax                      ;; C - B              eax
  400fdd:	sar    %eax                           ;; 这里是一个缩写 sar $1,%eax (对应的机器码为 D1F8)  eax = (C-B)/2
  400fdf:	lea    (%rax,%rsi,1),%ecx             ;; (C+B)/2               ecx        
  400fe2:	cmp    %edi,%ecx                      ;; ecx 与 A 进行比较               (1)
  400fe4:	jle    400ff2 &lt;func4+0x24&gt;            ;; ecx 小于等于 A 则跳转
  400fe6:	lea    -0x1(%rcx),%edx                ;; C = (C+B)/2 - 1
  400fe9:	callq  400fce &lt;func4&gt;                 ;; 递归调用
  400fee:	add    %eax,%eax                      ;; 递归返回值加倍
  400ff0:	jmp    401007 &lt;func4+0x39&gt;            ;; 跳转到 func 函数的出口处 
  400ff2:	mov    $0x0,%eax                      ;; eax = 0                      (2)
  400ff7:	cmp    %edi,%ecx                      ;; ecx 与 A 进行比较
  400ff9:	jge    401007 &lt;func4+0x39&gt;            ;; eax 大于等于 A 则跳转
  400ffb:	lea    0x1(%rcx),%esi                 ;; B = ecx + 1
  400ffe:	callq  400fce &lt;func4&gt;                 ;; 递归调用
  401003:	lea    0x1(%rax,%rax,1),%eax          ;; 递归返回值加倍并再加上 1
  401007:	add    $0x8,%rsp                      ;; 释放栈帧
  40100b:	retq                                  ;; 函数返回
</pre>
</div>

<p>
<code>func4</code> 对应的 C 语言描述：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #0086b3;">int</span> <span style="color: #b04c00;">func4</span><span style="color: #969896;">(</span><span style="color: #0086b3;">int</span> <span style="color: #756c00;">target</span>, <span style="color: #0086b3;">int</span> <span style="color: #637100;">step</span>, <span style="color: #0086b3;">int</span> <span style="color: #cb2a12;">limit</span><span style="color: #969896;">)</span> <span style="color: #969896;">{</span>
  <span style="color: #969896;">/* </span><span style="color: #969896;">edi = target; esi = step; edx = limit </span><span style="color: #969896;">*/</span>
  <span style="color: #0086b3;">int</span> <span style="color: #0085af;">temp</span> = <span style="color: #0086b3;">(</span><span style="color: #cb2a12;">limit</span> - <span style="color: #637100;">step</span><span style="color: #0086b3;">)</span> * <span style="color: #0086b3;">0.5</span>;
  <span style="color: #969896;">/* </span><span style="color: #969896;">all positive </span><span style="color: #969896;">*/</span>
  <span style="color: #0086b3;">int</span> <span style="color: #d8003c;">mid</span> = <span style="color: #0085af;">temp</span> + <span style="color: #637100;">step</span>;
  <span style="color: #0083d2;">if</span> <span style="color: #0086b3;">(</span><span style="color: #d8003c;">mid</span> &gt; <span style="color: #756c00;">target</span><span style="color: #0086b3;">)</span> <span style="color: #0086b3;">{</span>
    <span style="color: #cb2a12;">limit</span> = <span style="color: #d8003c;">mid</span> - <span style="color: #0086b3;">1</span>;
    <span style="color: #0086b3;">int</span> <span style="color: #b24b00;">ret1</span> = <span style="color: #b04c00;">func4</span><span style="color: #969896;">(</span><span style="color: #756c00;">target</span>, <span style="color: #637100;">step</span>, <span style="color: #cb2a12;">limit</span><span style="color: #969896;">)</span>;
    <span style="color: #0085a3;">return</span> <span style="color: #0086b3;">2</span> * <span style="color: #b24b00;">ret1</span>;
  <span style="color: #0086b3;">}</span> <span style="color: #0084c9;">else</span> <span style="color: #0086b3;">{</span>
    <span style="color: #0083d2;">if</span> <span style="color: #969896;">(</span><span style="color: #d8003c;">mid</span> &gt;= <span style="color: #756c00;">target</span><span style="color: #969896;">)</span> <span style="color: #969896;">{</span>
      <span style="color: #0085a3;">return</span> <span style="color: #0086b3;">0</span>;
    <span style="color: #969896;">}</span> <span style="color: #0084c9;">else</span> <span style="color: #969896;">{</span>
      <span style="color: #637100;">step</span> = <span style="color: #d8003c;">mid</span> + <span style="color: #0086b3;">1</span>;
      <span style="color: #0086b3;">int</span> <span style="color: #047c00;">ret2</span> = <span style="color: #b04c00;">func4</span><span style="color: #795da3;">(</span><span style="color: #756c00;">target</span>, <span style="color: #637100;">step</span>, <span style="color: #cb2a12;">limit</span><span style="color: #795da3;">)</span>;
      <span style="color: #0085a3;">return</span> <span style="color: #795da3;">(</span><span style="color: #0086b3;">2</span> * <span style="color: #047c00;">ret2</span> + <span style="color: #0086b3;">1</span><span style="color: #795da3;">)</span>;
    <span style="color: #969896;">}</span>
  <span style="color: #0086b3;">}</span>
<span style="color: #969896;">}</span>
</pre>
</div>

<p>
<b><code>solution_4</code></b>
</p>

<p>
有四组满足条件，以列表形式给出： <br />
<code>[(0, 0), (1, 0), (3, 0), (7, 0)]</code>
</p>

<p>
<b>备注</b> 递归自己理解的也不是很清晰，所以这一个 <code>phase</code> 就没有给出细致的讲解了。
</p>
</div>
</div>


<div id="outline-container-org2395c07" class="outline-2">
<h2 id="org2395c07"><code>phase_5</code></h2>
<div class="outline-text-2" id="text-org2395c07">
<p>
将 <code>phase_5</code> 的汇编代码来进行分析：
</p>
<div class="org-src-container">
<pre class="src src-ASM">0000000000401062 &lt;phase_5&gt;:
  401062:	push   %rbx                           ;; 保存 rbx
  401063:	sub    $0x20,%rsp                     ;; 分配栈帧
  401067:	mov    %rdi,%rbx                      ;; rbx 保存待比较字符串首地址
  40106a:	mov    %fs:0x28,%rax                  ;; (1) 以下注释开头有标号的为“栈破坏检测”，参看 CSAPP P199
  401071:	00 00 
  401073:	mov    %rax,0x18(%rsp)                ;; (2)
  401078:	xor    %eax,%eax                      ;; eax = 0
  40107a:	callq  40131b &lt;string_length&gt;         ;; 调用 string_length 函数
  40107f:	cmp    $0x6,%eax                      ;; string_length 函数返回值与 6 比较
  401082:	je     4010d2 &lt;phase_5+0x70&gt;          ;; 待比较字符串的长度为 6
  401084:	callq  40143a &lt;explode_bomb&gt;          ;; 否则，炸弹爆炸
  401089:	jmp    4010d2 &lt;phase_5+0x70&gt;          ;; 
  40108b:	movzbl (%rbx,%rax,1),%ecx             ;; 将待比较字符数组的元素依次拷贝到 ecx
  40108f:	mov    %cl,(%rsp)                     ;; 保存在 (%rsp) 处
  401092:	mov    (%rsp),%rdx                    ;; 将元素赋值给 rdx
  401096:	and    $0xf,%edx                      ;; 取 edx 的后四位
  401099:	movzbl 0x4024b0(%rdx),%edx            ;; 这里的地址是另一个关键
  4010a0:	mov    %dl,0x10(%rsp,%rax,1)          ;; 
  4010a4:	add    $0x1,%rax                      ;; 索引加 1
  4010a8:	cmp    $0x6,%rax                      ;; 索引小于 6
  4010ac:	jne    40108b &lt;phase_5+0x29&gt;          ;; 
  4010ae:	movb   $0x0,0x16(%rsp)                ;; 在字符数组的末尾添加 '\0'
  4010b3:	mov    $0x40245e,%esi                 ;; esi 指向源字符串的首地址  &lt;====== 与 phase_1 一样，这里的地址是关键之一
  4010b8:	lea    0x10(%rsp),%rdi                ;; 指示待比较的字符串
  4010bd: callq  401338 &lt;strings_not_equal&gt;     ;; 调用 strings_not_equal 函数
  4010c2:	test   %eax,%eax                      ;; 判断返回值是否为 0
  4010c4:	je     4010d9 &lt;phase_5+0x77&gt;          ;; 字符串相等则跳转
  4010c6:	callq  40143a &lt;explode_bomb&gt;          ;; 否则爆炸
  4010cb:	nopl   0x0(%rax,%rax,1)               ;;
  4010d0:	jmp    4010d9 &lt;phase_5+0x77&gt;          ;; 
  4010d2:	mov    $0x0,%eax                      ;; eax 置 0
  4010d7:	jmp    40108b &lt;phase_5+0x29&gt;          ;; 跳转
  4010d9:	mov    0x18(%rsp),%rax                ;; (3)
  4010de:	xor    %fs:0x28,%rax                  ;; (4) 
  4010e5:	00 00  
  4010e7:	je     4010ee &lt;phase_5+0x8c&gt;          ;; 判断“金丝雀”值是否遭到破坏
  4010e9:	callq  400b30 &lt;__stack_chk_fail@plt&gt;  ;; “金丝雀”值被破坏，故栈破换，调用异常处理函数
  4010ee:	add    $0x20,%rsp                     ;; 释放栈帧
  4010f2:	pop    %rbx                           ;; 恢复 rbx
  4010f3:	retq                                  ;; 函数返回
</pre>
</div>
<p>
跟 <code>phase_1</code> 一样，查看调用 <code>strings_not_equal</code> 的源字符串为 <code>flyers</code> （在 <code>gdb</code> 下使用 <code>x/s 0x40245e</code> 进行查看）。遂直接使用 <code>flyers</code> 进行试探， <code>Bomb!!!</code> 。那一定就是在调用 <code>strings_not_equal</code> 函数之前的那个循环做了一些其他的工作。可知， <code>strings_not_equal</code> 函数的第一个参数由 <code>rdi</code> 指出其首地址（ <code>4010b8: lea 0x10(%rsp),%edi</code> ），而再此之前也仅有以下三句汇编代码有对其进行赋值：
</p>
<div class="org-src-container">
<pre class="src src-ASM">401096:	and    $0xf,%edx                      ;; 取 edx 的后四位，则能够表示的大小为 0 - 15
401099:	movzbl 0x4024b0(%rdx),%edx            ;; edx 作为 =0x4024b0= 处字符数组的索引值
4010a0:	mov    %dl,0x10(%rsp,%rax,1)          ;; 将字符数组依次拷贝到 =0x10(%rsp)= 处
</pre>
</div>
<p>
查看 <code>0x4024b0</code> 处的内容（ <code>x/s 0x4024b0</code> ）为：
</p>
<blockquote>
<p>
"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"
</p>
</blockquote>
<p>
需要的是前面的 16 个字符，刚好是 <code>edx</code> 作为索引能够寻址到的内容，各自的 ASCII 对应为：
</p>


<div class="figure">
<p><img src="http://7xrxoi.com1.z0.glb.clouddn.com/target_strings_ascii.png" alt="target_strings_ascii.png" />
</p>
</div>

<p>
下面我们以源字符串中的字符 <code>f</code> 为例进行说明。
</p>
<ol class="org-ol">
<li><code>f</code> 在源字符数组中对应的索引为 <code>9</code> ，即 <code>edx</code> 在执行 <code>401099: movzbl 0x4024b0(%rdx),%edx</code> 时为 <code>9</code> （索引为 9 ）</li>
<li>需要在执行 <code>and $0xf,%edx</code> 时， <code>edx</code> 的后四位数表示为 <code>9</code> ，查看 ASCII 码表，满足条件的是 i (对应 ASCII 码为 <code>0x69</code> )和 y (对应 ASCII 码为 <code>0x79</code> )</li>
<li>因此， <code>i</code> 和 <code>y</code> 是满足条件的 <code>y</code> 的对应字符。</li>
<li>同理，可以得到其他的字符的对应。</li>
</ol>


<div class="figure">
<p><img src="http://7xrxoi.com1.z0.glb.clouddn.com/all_pairs.png" alt="all_pairs.png" />
</p>
</div>

<p>
<b><code>solutions_5</code></b>
</p>

<p>
由上图可知，总共有 16 ( = 2 * 1 * 1 * 2 * 2 * 2) 中满足条件的输入字符串，以列表形式表示为： <br />
["yonefg", "yonefw", "yonevg", &#x2026;]
</p>
</div>
</div>


<div id="outline-container-org7718d8a" class="outline-2">
<h2 id="org7718d8a"><code>phase_6</code></h2>
<div class="outline-text-2" id="text-org7718d8a">
<div class="org-src-container">
<pre class="src src-ASM">00000000004010f4 &lt;phase_6&gt;:
  4010f4:	push   %r14
  4010f6:	push   %r13
  4010f8:	push   %r12
  4010fa:	push   %rbp
  4010fb:	push   %rbx                       ;; 保存将要用到的各寄存器内容
  4010fc:	sub    $0x50,%rsp                 ;; 分配栈帧
  401100:	mov    %rsp,%r13                  ;;
  401103:	mov    %rsp,%rsi                  ;;
  401106:	callq  40145c &lt;read_six_numbers&gt;  ;; 读入 6 个数字
  40110b:	mov    %rsp,%r14                  ;;
  40110e:	mov    $0x0,%r12d                 ;;
  401114:	mov    %r13,%rbp                  ;;
  401117:	mov    0x0(%r13),%eax             ;;
  40111b:	sub    $0x1,%eax                  ;;
  40111e:	cmp    $0x5,%eax                  ;;
  401121:	jbe    401128 &lt;phase_6+0x34&gt;      ;;
  401123:	callq  40143a &lt;explode_bomb&gt;      ;;
  401128:	add    $0x1,%r12d                 ;;
  40112c:	cmp    $0x6,%r12d                 ;;
  401130: je     401153 &lt;phase_6+0x5f&gt;      ;;
  401132:	mov    %r12d,%ebx                 ;; r12d = 1    ---------------------------------
  401135:	movslq %ebx,%rax                  ;; ebx 初始化为 1 ，即 rax 从 1 开始索引    |
  401138:	mov    (%rsp,%rax,4),%eax         ;; rax 做为首地址为 (%rsp) 的数组的索引值   |
  40113b:	cmp    %eax,0x0(%rbp)             ;; 比较当前元素与数组的第一个元素是否相等   |
  40113e:	jne    401145 &lt;phase_6+0x51&gt;      ;; 不相等则跳转                             |
  401140:	callq  40143a &lt;explode_bomb&gt;      ;;                                          |
  401145:	add    $0x1,%ebx                  ;; ebx = ebx + 1 索引加 1                   |
  401148:	cmp    $0x5,%ebx                  ;; 总共读入 6 个数字 ebx &lt;= 5               |
  40114b:	jle    401135 &lt;phase_6+0x41&gt;      ;; 小于等于则跳转 -------------------------------
  40114d:	add    $0x4,%r13                  ;; 指向待考察的下一个数字
  401151:	jmp    401114 &lt;phase_6+0x20&gt;      ;; 无条件跳转
  401153:	lea    0x18(%rsp),%rsi            ;; 设置数组界限
  401158:	mov    %r14,%rax                  ;; rax 指向数组首地址
  40115b:	mov    $0x7,%ecx                  ;; ecx = 7
  401160:	mov    %ecx,%edx                  ;; edx = 7
  401162:	sub    (%rax),%edx                ;; a[i]
  401164:	mov    %edx,(%rax)                ;; a[i] = 7 - a[i]
  401166:	add    $0x4,%rax                  ;; i++
  40116a:	cmp    %rsi,%rax                  ;; i &lt; 6
  40116d:	jne    401160 &lt;phase_6+0x6c&gt;      ;; 循环
  40116f:	mov    $0x0,%esi                  ;; 初始化 esi = 0， 索引为 index = 0
  401174:	jmp    401197 &lt;phase_6+0xa3&gt;      ;; 跳转
  401176:	mov    0x8(%rdx),%rdx             ;; 
  40117a:	add    $0x1,%eax                  ;; eax = eax + 1
  40117d:	cmp    %ecx,%eax                  ;;
  40117f:	jne    401176 &lt;phase_6+0x82&gt;      ;;
  401181:	jmp    401188 &lt;phase_6+0x94&gt;      ;;
  401183:	mov    $0x6032d0,%edx             ;; edx = 0x6032d0
  401188:	mov    %rdx,0x20(%rsp,%rsi,2)     ;; 将 rdx 保存在 0x20(%rsp) 数组处
  40118d:	add    $0x4,%rsi                  ;; index++
  401191:	cmp    $0x18,%rsi                 ;; index &lt; 6
  401195:	je     4011ab &lt;phase_6+0xb7&gt;      ;; index == 6 则跳转
  401197:	mov    (%rsp,%rsi,1),%ecx         ;; 取数组元素 a[index]
  40119a:	cmp    $0x1,%ecx                  ;; a[index] 与 1 进行比较
  40119d:	jle    401183 &lt;phase_6+0x8f&gt;      ;; 小于等于 1 则跳转
  40119f:	mov    $0x1,%eax                  ;; eax = 1
  4011a4:	mov    $0x6032d0,%edx             ;; edx = 0x6032d0
  4011a9:	jmp    401176 &lt;phase_6+0x82&gt;      ;; 无条件跳转
  4011ab:	mov    0x20(%rsp),%rbx            ;; rbx = 0x6032f0
  4011b0:	lea    0x28(%rsp),%rax            ;; rax = 0x28(%rsp)
  4011b5:	lea    0x50(%rsp),%rsi            ;; 界限
  4011ba:	mov    %rbx,%rcx                  ;;
  4011bd:	mov    (%rax),%rdx                ;; 
  4011c0:	mov    %rdx,0x8(%rcx)             ;;
  4011c4:	add    $0x8,%rax                  ;;
  4011c8:	cmp    %rsi,%rax                  ;;
  4011cb:	je     4011d2 &lt;phase_6+0xde&gt;      ;;
  4011cd:	mov    %rdx,%rcx                  ;;
  4011d0:	jmp    4011bd &lt;phase_6+0xc9&gt;      ;;
  4011d2:	movq   $0x0,0x8(%rdx)             ;;
  4011d9:	00                                 
  4011da:	mov    $0x5,%ebp                  ;;
  4011df:	mov    0x8(%rbx),%rax             ;;
  4011e3:	mov    (%rax),%eax                ;;
  4011e5:	cmp    %eax,(%rbx)                ;;
  4011e7:	jge    4011ee &lt;phase_6+0xfa&gt;      ;;
  4011e9:	callq  40143a &lt;explode_bomb&gt;      ;;
  4011ee:	mov    0x8(%rbx),%rbx             ;;
  4011f2:	sub    $0x1,%ebp                  ;;
  4011f5:	jne    4011df &lt;phase_6+0xeb&gt;      ;;
  4011f7:	add    $0x50,%rsp                 ;;
  4011fb:	pop    %rbx                       ;; 恢复各个保存的寄存器值
  4011fc:	pop    %rbp
  4011fd:	pop    %r12
  4011ff:	pop    %r13
  401201:	pop    %r14
  401203:	retq                              ;; 函数返回
</pre>
</div>
<p>
对应的 C 语言描述为：
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #00845b;">static</span> <span style="color: #0086b3;">void</span> <span style="color: #ba4300;">phase_6</span><span style="color: #969896;">(</span><span style="color: #d31229;">const</span> <span style="color: #0086b3;">char</span> *<span style="color: #00858b;">str</span><span style="color: #969896;">)</span> <span style="color: #969896;">{</span>
  <span style="color: #0086b3;">int</span> <span style="color: #00800f;">a</span><span style="color: #0086b3;">[</span><span style="color: #0086b3;">6</span><span style="color: #0086b3;">]</span> = <span style="color: #0086b3;">{</span><span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span>, <span style="color: #0086b3;">0</span><span style="color: #0086b3;">}</span>;
  <span style="color: #7251d9;">read_six_numbers</span><span style="color: #0086b3;">(</span><span style="color: #00858b;">str</span>, <span style="color: #00800f;">a</span><span style="color: #0086b3;">)</span>;

  <span style="color: #0086b3;">int</span> *<span style="color: #447700;">t</span> = <span style="color: #00800f;">a</span>;              <span style="color: #969896;">/* </span><span style="color: #969896;">r13 </span><span style="color: #969896;">*/</span>
  <span style="color: #0086b3;">int</span> *<span style="color: #0085b1;">p</span> = <span style="color: #00800f;">a</span>;              <span style="color: #969896;">/* </span><span style="color: #969896;">r14 </span><span style="color: #969896;">*/</span>

  <span style="color: #0086b3;">int</span> <span style="color: #796b00;">i</span> = <span style="color: #0086b3;">0</span>;                    <span style="color: #969896;">/* </span><span style="color: #969896;">r12d </span><span style="color: #969896;">*/</span>

  <span style="color: #c73204;">while</span> <span style="color: #0086b3;">(</span><span style="color: #0086b3;">1</span><span style="color: #0086b3;">)</span> <span style="color: #0086b3;">{</span>
    <span style="color: #969896;">/* </span><span style="color: #969896;">&#21028;&#26029;&#35835;&#20837;&#30340; 6 &#20010;&#25968;&#22343;&#19981;&#30456;&#21516;&#65292;&#19988;&#22343;&#23567;&#20110;&#31561;&#20110;6 </span><span style="color: #969896;">*/</span>
    <span style="color: #0086b3;">int</span> *<span style="color: #756c00;">target</span> = <span style="color: #447700;">t</span>;              <span style="color: #969896;">/* </span><span style="color: #969896;">mov %r13,%rbp </span><span style="color: #969896;">*/</span>

    <span style="color: #0086b3;">int</span> <span style="color: #008460;">tmp</span> = *<span style="color: #447700;">t</span> - <span style="color: #0086b3;">1</span>;
    <span style="color: #0083d2;">if</span> <span style="color: #969896;">(</span><span style="color: #008460;">tmp</span> &lt;= <span style="color: #0086b3;">5</span><span style="color: #969896;">)</span> <span style="color: #969896;">{</span>
      <span style="color: #796b00;">i</span>++;
      <span style="color: #0083d2;">if</span> <span style="color: #795da3;">(</span><span style="color: #796b00;">i</span> != <span style="color: #0086b3;">6</span><span style="color: #795da3;">)</span> <span style="color: #795da3;">{</span>
        <span style="color: #0086b3;">int</span> <span style="color: #627200;">j</span> = <span style="color: #796b00;">i</span>;                    <span style="color: #969896;">/* </span><span style="color: #969896;">ebx </span><span style="color: #969896;">*/</span>
        <span style="color: #0086b3;">int</span> <span style="color: #0070f2;">index</span>;                    <span style="color: #969896;">/* </span><span style="color: #969896;">rax </span><span style="color: #969896;">*/</span>
        <span style="color: #d60035;">do</span> <span style="color: #969896;">{</span>
          <span style="color: #0070f2;">index</span> = <span style="color: #627200;">j</span>;
          <span style="color: #008460;">tmp</span> = <span style="color: #00800f;">a</span><span style="color: #a71d5d;">[</span><span style="color: #0070f2;">index</span><span style="color: #a71d5d;">]</span>;
          <span style="color: #0083d2;">if</span> <span style="color: #a71d5d;">(</span><span style="color: #008460;">tmp</span> == *<span style="color: #756c00;">target</span><span style="color: #a71d5d;">)</span> <span style="color: #a71d5d;">{</span>
            <span style="color: #d60075;">explode_bomb</span><span style="color: #969896;">()</span>;
          <span style="color: #a71d5d;">}</span>
          <span style="color: #627200;">j</span>++;
        <span style="color: #969896;">}</span> <span style="color: #c73204;">while</span> <span style="color: #969896;">(</span><span style="color: #627200;">j</span> &lt;= <span style="color: #0086b3;">5</span><span style="color: #969896;">)</span>;
        <span style="color: #447700;">t</span>++;
      <span style="color: #795da3;">}</span> <span style="color: #0084c9;">else</span> <span style="color: #795da3;">{</span>
        <span style="color: #c40e9e;">goto</span>: <span style="color: #a835bc;">label</span>;            <span style="color: #969896;">/* </span><span style="color: #969896;">&#24403; r12d == 6 &#26102; =je 401153=  </span><span style="color: #969896;">*/</span>
      <span style="color: #795da3;">}</span>
    <span style="color: #969896;">}</span> <span style="color: #0084c9;">else</span> <span style="color: #969896;">{</span>
      <span style="color: #d60075;">explode_bomb</span><span style="color: #795da3;">()</span>;
    <span style="color: #969896;">}</span>
  <span style="color: #0086b3;">}</span>

 <span style="color: #0086b3;">label</span>:
  <span style="color: #0082da;">for</span> <span style="color: #0086b3;">(</span><span style="color: #796b00;">i</span> = <span style="color: #0086b3;">0</span>; <span style="color: #796b00;">i</span> &lt; <span style="color: #0086b3;">6</span>; <span style="color: #796b00;">i</span>++<span style="color: #0086b3;">)</span> <span style="color: #0086b3;">{</span>
    <span style="color: #00800f;">a</span><span style="color: #969896;">[</span><span style="color: #796b00;">i</span><span style="color: #969896;">]</span> = <span style="color: #0086b3;">7</span> - <span style="color: #00800f;">a</span><span style="color: #969896;">[</span><span style="color: #796b00;">i</span><span style="color: #969896;">]</span>;
  <span style="color: #0086b3;">}</span>

  <span style="color: #969896;">/*</span><span style="color: #cc9393;">TODO</span><span style="color: #969896;">*/</span>

<span style="color: #969896;">}</span>
</pre>
</div>

<p>
感觉这道题，难度有点大，我是看了网上的答案之后，自己一步步 <code>si</code> 进行理解的。但还是有很多地方不太理解。就直接贴答案了，之后想通了再来补充理解吧。
</p>

<p>
<code>solution_6</code>
</p>

<p>
4 3 2 1 6 5
</p>
</div>
</div>


<div id="outline-container-org5778f33" class="outline-2">
<h2 id="org5778f33"><code>secret_phase</code></h2>
<div class="outline-text-2" id="text-org5778f33">
<div class="org-src-container">
<pre class="src src-ASM">0000000000401242 &lt;secret_phse&gt;:
  401242:	push   %rbx
  401243:	callq  40149e &lt;read_line&gt;           ;; 读取输入字符串， eax 返回首地址
  401248:	mov    $0xa,%edx                    ;; 字符串所采用的进制为十进制
  40124d:	mov    $0x0,%esi                    ;; NULL，表示该参数无效，或不使用该参数
  401252:	mov    %rax,%rdi                    ;; 待转换字符串的首地址
  401255:	callq  400bd0 &lt;strtol@plt&gt;          ;; 调用 strtol 将字符串转换为十进制整数值
  40125a:	mov    %rax,%rbx                    ;; 将返回结果保存在 rbx 中
  40125d:	lea    -0x1(%rax),%eax              ;; eax = eax - 1
  401260:	cmp    $0x3e8,%eax                  ;; 与 0x3e8 进行比较
  401265:	jbe    40126c &lt;secret_phase+0x2a&gt;   ;; 输入数字小于或等于 0x3e9
  401267:	callq  40143a &lt;explode_bomb&gt;        ;; 否则炸弹爆炸
  40126c:	mov    %ebx,%esi                    ;; 第二个参数 esi 保存输入数字
  40126e:	mov    $0x6030f0,%edi               ;; 第一个参数 edi = 0x6030f0 该地址对应的数值为 36
  401273:	callq  401204 &lt;fun7&gt;                ;; 调用 fun7
  401278:	cmp    $0x2,%eax                    ;; fun7 的返回值要求为 2
  40127b:	je     401282 &lt;secret_phase+0x40&gt;   ;; 返回 2 则跳转
  40127d:	callq  40143a &lt;explode_bomb&gt;        ;; 否则爆炸
  401282:	mov    $0x402438,%edi               ;; 对应的字符串为 "Wow! You've defused the secret stage!"
  401287:	callq  400b10 &lt;puts@plt&gt;            ;; 调用 puts 函数向控制台输出
  40128c:	callq  4015c4 &lt;phase_defused&gt;       ;; 调用 phase_defused 函数
  401291:	pop    %rbx                       
  401292:	retq
</pre>
</div>
<p>
得 <code>fun7</code> 函数的返回值必须为 2 。
</p>
<div class="org-src-container">
<pre class="src src-ASM">0000000000401204 &lt;fun7&gt;:
  401204:	sub    $0x8,%rsp
  401208:	test   %rdi,%rdi
  40120b:	je     401238 &lt;fun7+0x34&gt;
  40120d:	mov    (%rdi),%edx            ;;
  40120f:	cmp    %esi,%edx              ;;
  401211:	jle    401220 &lt;fun7+0x1c&gt;     ;;
  401213:	mov    0x8(%rdi),%rdi         ;;
  401217:	callq  401204 &lt;fun7&gt;          ;;
  40121c:	add    %eax,%eax              ;;
  40121e:	jmp    40123d &lt;fun7+0x39&gt;     ;;
  401220:	mov    $0x0,%eax              ;;
  401225:	cmp    %esi,%edx              ;;
  401227:	je     40123d &lt;fun7+0x39&gt;     ;;
  401229:	mov    0x10(%rdi),%rdi        ;;
  40122d:	callq  401204 &lt;fun7&gt;          ;;
  401232:	lea    0x1(%rax,%rax,1),%eax  ;;
  401236:	jmp    40123d &lt;fun7+0x39&gt;     ;;
  401238:	mov    $0xffffffff,%eax       ;;
  40123d:	add    $0x8,%rsp      
  401241:	retq
</pre>
</div>
<p>
对 <code>fun7</code> ，根据其汇编代码，写出等价的 C 语言递归函数：
</p>
<div class="org-src-container">
<pre class="src src-C">  <span style="color: #0086b3;">int</span> <span style="color: #c40b9c;">fun7</span><span style="color: #969896;">(</span><span style="color: #0086b3;">int</span> *<span style="color: #c63400;">x</span>, <span style="color: #0086b3;">int</span> <span style="color: #0085b1;">y</span><span style="color: #969896;">)</span> <span style="color: #969896;">{</span>
    <span style="color: #969896;">/* </span><span style="color: #969896;">rdi x; rsi y </span>
<span style="color: #969896;">*/</span>
    <span style="color: #0083d2;">if</span> <span style="color: #0086b3;">(</span><span style="color: #c63400;">x</span> == <span style="color: #0086b3;">NULL</span><span style="color: #0086b3;">)</span> <span style="color: #0086b3;">{</span>
      <span style="color: #0085a3;">return</span> -<span style="color: #0086b3;">1</span>;
    <span style="color: #0086b3;">}</span>

    <span style="color: #0086b3;">int</span> <span style="color: #008583;">ret</span> = <span style="color: #0086b3;">0</span>;
    <span style="color: #0083d2;">if</span> <span style="color: #0086b3;">(</span>*<span style="color: #c63400;">x</span> == <span style="color: #0085b1;">y</span><span style="color: #0086b3;">)</span> <span style="color: #0086b3;">{</span>                <span style="color: #969896;">/* </span><span style="color: #969896;">base </span><span style="color: #969896;">*/</span>
      <span style="color: #0085a3;">return</span> <span style="color: #0086b3;">0</span>;                                          <span style="color: #969896;">// </span><span style="color: #969896;">1</span>
    <span style="color: #0086b3;">}</span>

    <span style="color: #0083d2;">if</span> <span style="color: #0086b3;">(</span>*<span style="color: #c63400;">x</span> &lt; <span style="color: #0085b1;">y</span><span style="color: #0086b3;">)</span> <span style="color: #0086b3;">{</span>
      <span style="color: #008583;">ret</span> = <span style="color: #c40b9c;">fun7</span><span style="color: #969896;">(</span>*<span style="color: #795da3;">(</span><span style="color: #c63400;">x</span> + <span style="color: #0086b3;">0x10</span><span style="color: #795da3;">)</span>, <span style="color: #0085b1;">y</span><span style="color: #969896;">)</span>;                        <span style="color: #969896;">// </span><span style="color: #969896;">2</span>
      <span style="color: #0085a3;">return</span> <span style="color: #969896;">(</span><span style="color: #0086b3;">2</span> * <span style="color: #008583;">ret</span> + <span style="color: #0086b3;">1</span><span style="color: #969896;">)</span>;
    <span style="color: #0086b3;">}</span> <span style="color: #0084c9;">else</span> <span style="color: #0086b3;">{</span>                      <span style="color: #969896;">/* </span><span style="color: #969896;">*x &gt; y </span><span style="color: #969896;">*/</span>
      <span style="color: #008583;">ret</span> = <span style="color: #c40b9c;">fun7</span><span style="color: #969896;">(</span>*<span style="color: #795da3;">(</span><span style="color: #c63400;">x</span> + <span style="color: #0086b3;">0x8</span><span style="color: #795da3;">)</span>, <span style="color: #0085b1;">y</span><span style="color: #969896;">)</span>;                         <span style="color: #969896;">// </span><span style="color: #969896;">3</span>
      <span style="color: #0085a3;">return</span> <span style="color: #969896;">(</span><span style="color: #0086b3;">2</span> * <span style="color: #008583;">ret</span><span style="color: #969896;">)</span>;
    <span style="color: #0086b3;">}</span>
  <span style="color: #969896;">}</span>
</pre>
</div>
<p>
那么，为了让 <code>fun7</code> 返回得到 2，需要执行三次递归：
</p>
<ol class="org-ol">
<li>2 = 2 * 1</li>
<li>1 = 2 * 0 + 1</li>
<li>0 = 0</li>
</ol>

<p>
执行这个递归调用时，进入时地址为 <code>0x6030f0</code> ， <code>*x &gt; y</code> 执行到标号 3 的那行语句时，递归，此时第一个参数地址加 <code>0x8</code> ， <code>*x &lt; y</code> 执行到标号 2 时第二层递归，第一个参数地址再加上 <code>0x10</code> , 执行时 <code>*x == y</code> 函数返回 0，依次返回，最后 <code>secret_phase</code> 调用 <code>fun7</code> 返回 2 符合要求。
</p>

<p>
查看 0x603108 ( = 0x6030f0 + 0x8 + 0x10 ) 内存单元即为所求， <code>x/dw 0x603108</code> 。 
</p>

<p>
<code>solution_secret</code>
</p>

<p>
0
</p>

<p>
经历了上面的这么多折磨之后，终于迎来了最后的时刻，至此，所有 <code>phase</code> 均通过
</p>


<div class="figure">
<p><img src="http://7xrxoi.com1.z0.glb.clouddn.com/all_pass.png" alt="all_pass.png" />
</p>
</div>

<p>
部分题目有多个满足要求的解答，在文中亦有详细说明，截图中仅分别给出了一种情况作为测试。
</p>
</div>
</div>


<div id="outline-container-org586dc20" class="outline-2">
<h2 id="org586dc20">总结</h2>
</div>


<div id="outline-container-orgf697da0" class="outline-2">
<h2 id="orgf697da0">参考资料</h2>
<div class="outline-text-2" id="text-orgf697da0">
<ul class="org-ul">
<li><a href="https://courses.cs.washington.edu/courses/cse351/16sp/lab-2.html">CSE 351 Lab2</a></li>
<li><a href="http://stackoverflow.com/questions/12813962/sar-command-in-x86-assembly-with-one-parameter">SAR command in x86 assembly with one parameter</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="sitemap"><a href="https://aprilwith.me">Other posts</a></div>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
              /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
              var disqus_shortname = 'bastibe';
              /* * * DON'T EDIT BELOW THIS LINE * * */
              (function() {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                  })();
              </script>
              <noscript>Please enable JavaScript to view the
                  <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
</body>
</html>
